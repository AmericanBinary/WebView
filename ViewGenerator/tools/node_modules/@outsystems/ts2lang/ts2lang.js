"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var analyser = require("./ts-analyser");
var Templates = require("./template-runner");
var configuration_1 = require("./configuration");
var path_1 = require("path");
var merge = require("merge");
var fs_1 = require("fs");
var is_directory_1 = require("is-directory");
var glob = require("glob");
function getProjectPaths(requestedPath) {
    var DEFAULT_PROJ_FILENAME = "./ts2lang.json";
    if (!requestedPath) {
        requestedPath = DEFAULT_PROJ_FILENAME;
    }
    if (is_directory_1.sync(requestedPath)) {
        return {
            filePath: path_1.resolve(requestedPath, DEFAULT_PROJ_FILENAME),
            fileDir: requestedPath,
        };
    }
    return {
        filePath: requestedPath,
        fileDir: path_1.dirname(requestedPath),
    };
}
exports.getProjectPaths = getProjectPaths;
function assertProjectExists(filePath) {
    if (!fs_1.existsSync(filePath)) {
        console.error("Couldn't file project file.");
        console.error("Was looking for it in " + filePath);
        throw new Error("Project file not found.");
    }
}
exports.assertProjectExists = assertProjectExists;
function runProject(filePath, fileDir, defaultTemplate) {
    var compilerOptions = {
        noEmitOnError: true,
        noImplicitAny: true,
        target: ts.ScriptTarget.ES5,
        module: ts.ModuleKind.AMD,
        rootDir: fileDir
    };
    var configuration = configuration_1.read(filePath);
    var compilerHost = ts.createCompilerHost(compilerOptions, true);
    configuration.tasks.forEach(function (task) {
        var sources = [];
        var input = task.input;
        if (typeof input === "string") {
            var inputPath = path_1.resolve(fileDir, input);
            sources = glob.sync(inputPath);
        }
        else {
            sources = input.map(function (path) { return path_1.resolve(fileDir, path); });
        }
        var program = ts.createProgram(sources, compilerOptions, compilerHost);
        var sourceFiles = program.getSourceFiles();
        sources.forEach(function (source) {
            var file = sourceFiles.filter(function (file) { return isSamePath(file.fileName, source); })[0];
            if (!file) {
                console.error("Couldn't file source file " + source + ".");
                throw new Error("Source file not found.");
            }
            var taskParameters = configuration_1.getTaskParameters(task);
            var template = task.template || defaultTemplate;
            var context = merge({
                $fullpath: file.fileName,
                $path: task.input,
                $output: task.output,
                $template: template,
            }, taskParameters);
            try {
                var transformed = Templates
                    .loadTemplate(path_1.resolve(fileDir, template))
                    .transform(analyser.collectInformation(program, file, file.fileName), context);
                if (transformed) {
                    output(transformed, fileDir, context.$output);
                }
            }
            catch (e) {
                console.error("Error transforming source file " + source + ": " + e.stack);
                throw new Error("Error transforming source file.");
            }
        });
    });
}
exports.runProject = runProject;
function output(content, targetDir, target) {
    if (!target || target === "-") {
        process.stdout.write(content);
    }
    else {
        var outputPath = path_1.resolve(targetDir, target);
        ensureDirectoryExists(path_1.dirname(outputPath));
        fs_1.writeFileSync(outputPath, content);
    }
}
function ensureDirectoryExists(path) {
    path = path.replace(/\\/g, path_1.sep);
    path.split(path_1.sep).reduce(function (prev, curr) {
        var aggregatedPath = prev + path_1.sep + curr;
        if (fs_1.existsSync(aggregatedPath) === false) {
            fs_1.mkdirSync(aggregatedPath);
        }
        return aggregatedPath;
    });
}
function isSamePath(path1, path2) {
    var p1 = path_1.normalize(path1).toLowerCase();
    var p2 = path_1.normalize(path2).toLowerCase();
    return p1 === p2;
}
